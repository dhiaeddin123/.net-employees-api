using System.Linq.Expressions;
using blockchain_api.Data;
using blockchain_api.Data.Models;
using blockchain_api.Requests;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

[Route("api/[controller]")]
[ApiController]
public class LeaveRequestsController : ControllerBase
{
    private readonly DataContext _context;

    public LeaveRequestsController(DataContext context)
    {
        _context = context;
    }

    // GET: api/LeaveRequests
    [HttpGet]
    public async Task<ActionResult<IEnumerable<LeaveRequest>>> GetLeaveRequests()
    {
        return await _context.LeaveRequests.ToListAsync();
    }

    // GET: api/LeaveRequests/5
    [HttpGet("{id}")]
    public async Task<ActionResult<LeaveRequest>> GetLeaveRequest(int id)
    {
        var leaveRequest = await _context.LeaveRequests.FindAsync(id);

        if (leaveRequest == null)
        {
            return NotFound();
        }

        return leaveRequest;
    }

    // POST: api/LeaveRequests
    [HttpPost]
    public async Task<ActionResult<LeaveRequest>> CreateLeaveRequest([FromBody] CreateLeaveRequestDto dto)
    {
        // Business Rule: Sick leave must have a reason
        if (dto.LeaveType == LeaveType.Sick && string.IsNullOrWhiteSpace(dto.Reason))
            return BadRequest("Sick leave must have a non-empty reason.");

        // Business Rule: No overlapping dates for the same employee
        if (dto.StartDate.HasValue && dto.EndDate.HasValue)
        {
            var overlapping = await _context.LeaveRequests.AnyAsync(lr =>
                lr.EmployeeId == dto.EmployeeId &&
                lr.StartDate <= dto.EndDate &&
                lr.EndDate >= dto.StartDate
            );

            if (overlapping)
                return BadRequest("Employee already has a leave request that overlaps with these dates.");
        }   

        // Business Rule: Max 20 Annual Leave Days per Year
        if (dto.LeaveType == LeaveType.Annual && dto.StartDate.HasValue && dto.EndDate.HasValue)
        {
            var year = dto.StartDate.Value.Year;
            var annualLeaves = await _context.LeaveRequests
                .Where(lr => lr.EmployeeId == dto.EmployeeId
                        && lr.LeaveType == LeaveType.Annual
                        && lr.StartDate.Value.Year == year)
                .ToListAsync();

            int existingDays = annualLeaves.Sum(lr => (lr.EndDate ?? lr.StartDate).Value.DayNumber - lr.StartDate.Value.DayNumber + 1);
            int newDays = (dto.EndDate.Value.DayNumber - dto.StartDate.Value.DayNumber + 1);

            if (existingDays + newDays > 20)
                return BadRequest("Employee exceeds the maximum 20 annual leave days for the year.");
        } 

        // Optionally: Check if EmployeeId exists
        var employeeExists = await _context.Employees.AnyAsync(e => e.Id == dto.EmployeeId);
        if (!employeeExists)
        {
            return BadRequest($"No employee found with ID {dto.EmployeeId}.");
        }

        var leaveRequest = new LeaveRequest
        {
            EmployeeId = dto.EmployeeId,
            LeaveType = (LeaveType)dto.LeaveType,
            StartDate = dto.StartDate,
            EndDate = dto.EndDate,
            Reason = dto.Reason,
            Status = LeaveRequestStatus.Pending,
            // CreatedAt will be auto-generated by the database
        };

        _context.LeaveRequests.Add(leaveRequest);
        await _context.SaveChangesAsync();

        // Now re-fetch the created leaveRequest with its Employee
        var createdLeaveRequest = await _context.LeaveRequests
            .Include(lr => lr.Employee)
            .FirstOrDefaultAsync(lr => lr.Id == leaveRequest.Id);

        return CreatedAtAction(nameof(GetLeaveRequest), new { id = leaveRequest.Id }, leaveRequest);
    }

    // PUT: api/LeaveRequests/5
    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateLeaveRequest(int id, [FromBody] UpdateLeaveRequestDto dto)
    {
        // Business Rule: Sick leave must have a reason
        if (dto.LeaveType == LeaveType.Sick && string.IsNullOrWhiteSpace(dto.Reason))
            return BadRequest("Sick leave must have a non-empty reason.");

        // Business Rule: No overlapping dates for the same employee
        if (dto.StartDate.HasValue && dto.EndDate.HasValue)
        {
            var overlapping = await _context.LeaveRequests.AnyAsync(lr =>
                lr.EmployeeId == dto.EmployeeId &&
                lr.StartDate <= dto.EndDate &&
                lr.EndDate >= dto.StartDate
            );

            if (overlapping)
                return BadRequest("Employee already has a leave request that overlaps with these dates.");
        }   

        // Business Rule: Max 20 Annual Leave Days per Year
        if (dto.LeaveType == LeaveType.Annual && dto.StartDate.HasValue && dto.EndDate.HasValue)
        {
            var year = dto.StartDate.Value.Year;
            var annualLeaves = await _context.LeaveRequests
                .Where(lr => lr.EmployeeId == dto.EmployeeId
                        && lr.LeaveType == LeaveType.Annual
                        && lr.StartDate.Value.Year == year)
                .ToListAsync();

            int existingDays = annualLeaves.Sum(lr => (lr.EndDate ?? lr.StartDate).Value.DayNumber - lr.StartDate.Value.DayNumber + 1);
            int newDays = (dto.EndDate.Value.DayNumber - dto.StartDate.Value.DayNumber + 1);

            if (existingDays + newDays > 20)
                return BadRequest("Employee exceeds the maximum 20 annual leave days for the year.");
        } 

        // Step 1: Check if the LeaveRequest exists
        var leaveRequest = await _context.LeaveRequests
            .Include(lr => lr.Employee)  // Optional, to avoid circular reference
            .FirstOrDefaultAsync(lr => lr.Id == id);

        if (leaveRequest == null)
        {
            return NotFound();
        }

        // Step 2: Check if Employee exists (only if EmployeeId is provided)
        if (dto.EmployeeId.HasValue)
        {
            var employeeExists = await _context.Employees.AnyAsync(e => e.Id == dto.EmployeeId);
            if (!employeeExists)
            {
                return BadRequest($"No employee found with ID {dto.EmployeeId}.");
            }
            leaveRequest.EmployeeId = dto.EmployeeId.Value;
        }

        // Step 3: Update only the provided fields
        if (dto.LeaveType != null)
            leaveRequest.LeaveType = (LeaveType)dto.LeaveType;

        if (dto.StartDate.HasValue)
            leaveRequest.StartDate = dto.StartDate.Value;

        if (dto.EndDate.HasValue)
            leaveRequest.EndDate = dto.EndDate.Value;

        if (dto.Reason != null)
            leaveRequest.Reason = dto.Reason;

        if (dto.Status != null)
            leaveRequest.Status = (LeaveRequestStatus)dto.Status;

        // Step 4: Save changes to the database
        await _context.SaveChangesAsync();

        // Step 5: Re-fetch the LeaveRequest with its updated Employee data (if needed)
        var updatedLeaveRequest = await _context.LeaveRequests
            .Include(lr => lr.Employee)  // Make sure to include the Employee object here
            .FirstOrDefaultAsync(lr => lr.Id == leaveRequest.Id);

        return Ok(updatedLeaveRequest);
    }

    // DELETE: api/LeaveRequests/5
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteLeaveRequest(int id)
    {
        var leaveRequest = await _context.LeaveRequests.FindAsync(id);
        if (leaveRequest == null)
        {
            return NotFound();
        }

        _context.LeaveRequests.Remove(leaveRequest);
        await _context.SaveChangesAsync();

        return NoContent();
    }

    [HttpGet("filter")]
    public async Task<IActionResult> FilterLeaveRequests(
        [FromQuery] int? employeeId,
        [FromQuery] LeaveType? leaveType,
        [FromQuery] LeaveRequestStatus? status,
        [FromQuery] DateOnly? startDate,
        [FromQuery] DateOnly? endDate,
        [FromQuery] string? keyword,
        [FromQuery] string? sortBy = "Id",
        [FromQuery] string? sortOrder = "asc",
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 10)
    {
        var query = _context.LeaveRequests.AsQueryable();

        // Apply Filters
        if (employeeId.HasValue)
            query = query.Where(lr => lr.EmployeeId == employeeId.Value);

        if (leaveType.HasValue)
            query = query.Where(lr => lr.LeaveType == leaveType.Value);

        if (status.HasValue)
            query = query.Where(lr => lr.Status == status.Value);

        if (startDate.HasValue)
            query = query.Where(lr => lr.StartDate >= startDate.Value);

        if (endDate.HasValue)
            query = query.Where(lr => lr.EndDate != null && lr.EndDate <= endDate.Value);

        if (!string.IsNullOrWhiteSpace(keyword))
            query = query.Where(lr => lr.Reason != null && lr.Reason.Contains(keyword));

        // Dynamic Sorting
        var sortFields = new Dictionary<string, Expression<Func<LeaveRequest, object>>>(StringComparer.OrdinalIgnoreCase)
        {
            { "leaveType", lr => lr.LeaveType },
            { "startDate", lr => lr.StartDate },
            { "endDate", lr => lr.EndDate },
            { "status", lr => lr.Status },
            { "createdAt", lr => lr.CreatedAt }
        };

        if (sortFields.TryGetValue(sortBy, out var sortExpression))
        {
            query = sortOrder?.ToLower() == "desc"
                ? query.OrderByDescending(sortExpression)
                : query.OrderBy(sortExpression);
        }

        // Pagination
        var totalCount = await query.CountAsync();
        var totalPages = (int)Math.Ceiling(totalCount / (double)pageSize);

        var leaveRequests = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        return Ok(new
        {
            Page = page,
            PageSize = pageSize,
            TotalPages = totalPages,
            TotalCount = totalCount,
            Data = leaveRequests
        });
    }

    [HttpGet("report")]
    public async Task<IActionResult> GetLeaveRequestsReport(int year, string? department, DateOnly? startDate, DateOnly? endDate)
    {
        var query = _context.LeaveRequests
            .Include(lr => lr.Employee)
            .AsQueryable();

        // Filter by year (based on StartDate)
        query = query.Where(lr => lr.StartDate.Value.Year == year);

        // Optional: Filter by department
        if (!string.IsNullOrEmpty(department))
        {
            query = query.Where(lr => lr.Employee.Department == department);
        }

        // Optional: Filter by date range
        if (startDate.HasValue)
        {
            query = query.Where(lr => lr.StartDate >= startDate.Value);
        }

        if (endDate.HasValue)
        {
            query = query.Where(lr => (lr.EndDate ?? lr.StartDate) <= endDate.Value);
        }

        var result = await query
            .GroupBy(lr => new { lr.Employee.Id, lr.Employee.FullName })
            .Select(g => new
            {
                Employee = g.Key.FullName,
                TotalLeaves = g.Count(),
                AnnualLeaves = g.Count(lr => lr.LeaveType == LeaveType.Annual),
                SickLeaves = g.Count(lr => lr.LeaveType == LeaveType.Sick)
            })
            .ToListAsync();

        return Ok(result);
    }

    [HttpPost("{id}/approve")]
    public async Task<IActionResult> ApproveLeaveRequest(int id)
    {
        var leaveRequest = await _context.LeaveRequests.FindAsync(id);

        if (leaveRequest == null)
        {
            return NotFound(new { message = "Leave request not found." });
        }

        if (leaveRequest.Status != LeaveRequestStatus.Pending)
        {
            return BadRequest(new { message = "Only pending leave requests can be approved." });
        }

        leaveRequest.Status = LeaveRequestStatus.Approved;
        await _context.SaveChangesAsync();

        // Fetch the updated leave request (including Employee if needed)
        var updatedLeaveRequest = await _context.LeaveRequests
            .Include(lr => lr.Employee)
            .FirstOrDefaultAsync(lr => lr.Id == id);

        return Ok(updatedLeaveRequest);
    }
}
